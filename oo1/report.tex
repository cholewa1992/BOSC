\documentclass[danish]{report}

\usepackage[utf8]{inputenc}
\usepackage[danish]{babel}
\usepackage{listings}
\usepackage{color}
\usepackage{courier}
\usepackage{parskip}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{
  frame=,
  language=C,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true
  tabsize=4
}

% Title Page
\title{Obligatorisk opgave 1}
\author{Jacob B. Cholewa, Rasmus L. Wismann \& Nikolai Storr }


\begin{document}
\maketitle
\newpage
\tableofcontents
\newpage

\chapter{Introduktion}

I denne rapport vil vi beskrive hvordan vi har implementeret vores version af Shellen BOSC og den teori der ligger til grund for denne implementation. Rapporten er opdelt i tre sektioner, en introduktion, et implementations og teori afsnit og til sidste en konklusion. Næste sektion indeholder kravene til vores Shell.  

\section{Features}
\begin{enumerate}
\item bosh skal kunne virke uafhængigt. Du må ikke bruge andre eksisterende shells, f.eks. er det ikke tilladt at anvende et systemkald {\tt system()} til at starte {\tt bash}.
\item En bruger skal kunne indtaste almindelige enkeltstående kommandoer, så som {\tt ls}, {\tt cat} og {\tt wc}. Hvis kommandoen ikke findes i operativ systemet skal der udskrives en ”Command not found“ meddelelse.
\item Kommandoer skal kunne eksekvere som baggrundsprocesser (ved brug af \&) såadan at mange programmer kan køres på samme tid.
\item Der skal være indbygget funktionalitet som gør de muligt at lave redirection af stdin og stdout til filer. F.eks skal kommandoen {\tt wc -l < /etc/passwd > antalkontoer} lave en fil ”antalkontoer“, der indeholder antallet af brugerkontoer.
\item Det skal være muligt at anvende pipes. F.eks. skal {\tt ls | wc -w} udskrive antallet af filer.
\item Funktionen {\tt exit} skal være indbygget til at afslutte shell’en.
\item Tryk på Ctrl-C skal afslutte det program, der kører i {\tt bosh} shell’en, men ikke shell’en selv.
\end{enumerate}

\chapter{Implementation og teori}
\section{Feature 1 og 2}
Første krav til vores shell er at vi ikke bruger andre shells til at få vores shell eller systemkald til at virke. Det skal altså være et selvstående program. En shell er en grafisk brugergrænseflade der tillader brugeren at inputte og køre programmer. Shellen er altså en process der kan starte andre programmer som processer. For at en bruger kan eksekvere programmer på maskinen så som {\tt ls}, {\tt cat} og {\tt wc} skal vi kigge i de forskelle {\tt bin} arkiver. Vi har skrevet vores shell til linux systemer, og vi leder derfor efter det inputtede program i mapperne {\tt ./}, {\tt /bin/} og {\tt /usr/bin/}. Hvis vi finder programmet som brugeren prøver at starte bruger vi vi det indbyggede program i linux {\tt execvp}. {\tt execvp} programmet tager en process og bytter det ud med en anden process. Det første vi gør er derfor at oprette en nye process med {\tt fork()}. Fork opretter en kopi af den eksisterende process. Den nye process kaldes for en \textit{child process} og den eksisternede process for en \textit{parrent process}. Dette gøres med følgende kode.

\begin{lstlisting}

... Parrent process code

pid_t pid = fork();
if(pid == 0){
    ... Child process code ...
}else{
    ... Parrent process code ...
}

... Parrent and child process code ...

\end{lstlisting}

Når vi har lavet et kopi af shell processen bytter vi ved brug af {\tt execvp} \textit{child processen} ud med det program som brugeren ønskede at starte. På den måde kan vi starte programmer som nye processer fra vores BOSC shell.

\section{Feature 3}

Hvis en kommando køres med symbolet {\tt \&} skal processen startes som en baggrundsprocess. Vi ønsker denne feature fordi at en bruger skal kunne køre flere programmer fra shell'en på samme tid. Når vi starter en process vil vi gerne vente på den terminiene inden vi igen tillader input fra brugeren. Dette gør vi med {\tt waitpid(process\_id, status\_location, options)}. Når vi starter en baggrundsproces vælger altså derfor blot ikke at vente på barne processen og lader derfor strakts brugeren indtaste nyt input. Som det kan ses i kode stykket nedenfor venter vi derfor kun på barne processen hvis {\tt background} er {\tt 0} ({\tt false}). {\tt shellcmd} er en struct vi bruger til at holde brugerens kommando. 
\begin{lstlisting}
int executeshellcmd(Shellcmd *shellcmd){
    

    ... code to check shellcmd

    pid_t pid = fork();
    if(pid == 0){
           ... Code executing the user input program ...
    }else{
        if(shellcmd -> background == 0){
            int wstatus = 0;    
            waitpid(pid,&wstatus,0);
        }
    }
    return 0;
}
\end{lstlisting}

\section{Feature 4}

Hvis symbolet {\tt >} optræder i kommandoen skal vi omdirigere output til filnavnet på venstre side. eg. {\tt cmd > file}. På samme måde skal vi hvis symbolet {\tt <} optræder i kommandoen omdirigere input til at være filen fra venstre side. eg {\tt cmd < file}. 

Redirect {\tt >} og {\tt <}, er syntaks der omdirigerer processers input og output. Ved kaldet {\tt p1 > p2} , sættes p1's output filedescriptor til p2's input  filedescriptor.       

Dette har vi implementeret med følgende logik.

\begin{lstlisting}
if(in == NULL && out == NULL){
                status = executecmd(cmdlist);
            }else{
                if(in != NULL && out != NULL) status = redirInOut(in, out, cmdlist);
                if(in != NULL) status = redirIn(in, cmdlist);
                if(out != NULL) status = redirOut(out, cmdlist);
            }
\end{lstlisting}

som bruger følgende hjælpe metoder.

\begin{lstlisting}
// redirect in and out
int redirInOut(char *inFile, char *outFile, Cmd *cmdlist){
    
    int fidIn  = open(inFile, O_RDONLY);
    int fidOut = open(outFile, O_WRONLY | O_CREAT | O_APPEND);              
    close(0); close(1);
    dup(fidIn); dup(fidOut);
    int status = executecmd(cmdlist);
    close(fidIn); close(fidOut);
    if(status != 0) 
        printf("execvp returned: %i, errno returned: %i 'no such file or directory' \n", status, errno);

}

// redirect in
int redirIn(char *inFile, Cmd *cmdlist){
    int fid = open(inFile, O_RDONLY);  
    close(0); // close standard input
    dup(fid);   // 'duplicate fileid', opens another input (file)    
    int status = executecmd(cmdlist);
    close(fid);             
    if(status != 0) 
        printf("execvp returned: %i, errno returned: %i 'no such file or directory' \n", status, errno);


}

// redirect out
int redirOut(char *outFile, Cmd *cmdlist){
    int fid = open(outFile, O_WRONLY | O_CREAT | O_APPEND);         
    close(1); // close standard output
    dup(fid); // duplicate file-descriptor

    int status = executecmd(cmdlist);
    close(fid);             
    if(status != 0) 
        printf("execvp returned: %i, errno returned: %i 'no such file or directory' \n", status, errno);

}
\end{lstlisting}





\section{Feature 5}

En pipe (skrives med symbol {\tt |}) tager outputtet fra kommandoen på højre side og bruger det som input til kommandoen på venstre side. E.g. {\tt c1 | c2 | c3 } tager output fra c1 og giver til c2 som input osv. 

En pipe er et systemkald som opretter en envejs kommunikation mellem to processer. Kaldet {\tt pipe}, tager en array med to elementer, de to processer's henh. out - og input filedescriptors. Først kalder vi {\tt pipe} med en {\tt int fd[2]} array som argument, dernæst sætter vi arrayens to elementer til et output og et input ved at kopiere processernes respektive filedescriptors med {\tt dup }. Vi lukker så den første process' output filedescriptor og den næste process' input filedescriptor. Nu kan det som puttes ind i den ene ende læses i den anden.  

Vi har i vores shell implementeret dette med følgende logik. Denne metode kaldes af de metoder som var vist i feature 4.

\begin{lstlisting}
int executecmd(Cmd *cmdlist){
    int status;
    char **cmd = cmdlist -> cmd;
    Cmd *next = cmdlist -> next;
    if(next != NULL){

        int fd[2];
        pipe(fd);

        pid_t pid = fork();
        if(pid == 0){
            close(fd[0]);
            close(1);
            dup(fd[1]);
            close(fd[1]);
            status = executecmd(next);
        }else{
            close(fd[1]);
            close(0);
            dup(fd[0]);
            close(fd[0]);
            status = execvp(*cmd,cmd);
            
            int wstatus;
            waitpid(pid,&wstatus,0);
        }
    }else{
        status = execvp(*cmd,cmd);
    }
    return status;
}

\end{lstlisting}

\section{Feature 6 og 7}

Et signal eller et interrupt er en event som midlertidigt overlader program kontrollen til et andet program eller funktion. Når funktionen eller programmet er færdigt kan kontrollen overlades til den 'interruptede' process som så kan fortsætte. Man skelner mellem hardware og software interrupts.

Et software interrupt eller signal er en asynkron aktivitet. i.e., processer venter ikke på signalet. Det program eller den funktion der er designet til at svare på en event siges at fange den, eller på engelsk,  at 'trap' eller 'handle' eventen. Derfor kaldes den typisk en 'signal handler'. 

Et program tildeles en række default handlers som udgør events som det kan 'fange'. Eksempelvis, hvis et program kører i en prompt, vil tastekombinationen ctrl-c blive fanget af en handler hvis default handling er at terminere processen. 

\subsection{Implementation}
Vi har implementeret en signal handler der fanger ctrl-c interrupts. Når vi forker en ny process attacher vi vores signal handler. Det sker både i executecmd metoden og i executeshellcmd metoden, fordi vi forker nye processer begge disse to steder. 

\begin{lstlisting}
...
pid_t pid = fork();
if(pid == 0){
	// setup a signal handler for this thread
	signal(SIGINT, leave);
...
\end{lstlisting}

Når man herefter trykker ctrl-c bliver program kontrollen overført til vores handler metode. Her kan vi så exitte processen hvis den er forked. Hvis den ikke er forked må det være vores bosh shell og så gør metoden intet. 

\begin{lstlisting}
// signal handler
void leave(int sig){
	pid_t pid = getpid();
	if(pid == 0){
		// thread interrupt
		exit(sig);
	}
}
\end{lstlisting}


Hvorefter kontrollen gives tilbage til bosh shell.

\chapter{Konklusion}
\end{document}          
