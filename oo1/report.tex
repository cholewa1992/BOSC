\documentclass[danish]{report}

\usepackage[utf8]{inputenc}
\usepackage[danish]{babel}
\usepackage{listings}
\usepackage{color}
\usepackage{courier}
\usepackage{parskip}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{
  frame=,
  language=C,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true
  tabsize=4
}

% Title Page
\title{Obligatorisk opgave 1}
\author{Jacob B. Cholewa, Rasmus L. Wismann \& Nikolai Storr }


\begin{document}
\maketitle
\newpage
\tableofcontents
\newpage

\chapter{Introduktion}

I denne rapport vil vi beskrive hvordan vi har implementeret vores version af Shellen BOSC og den teori der ligger til grund for denne implementation. Rapporten er opdelt i tre sektioner, en introduktion, et implementations og teori afsnit og til sidste en konklusion. Næste sektion indeholder kravene til vores Shell.  

\section{Features}
\begin{enumerate}
\item bosh skal kunne virke uafhængigt. Du må ikke bruge andre eksisterende shells, f.eks. er det ikke tilladt at anvende et systemkald {\tt system()} til at starte {\tt bash}.
\item En bruger skal kunne indtaste almindelige enkeltstående kommandoer, så som {\tt ls}, {\tt cat} og {\tt wc}. Hvis kommandoen ikke findes i operativ systemet skal der udskrives en ”Command not found“ meddelelse.
\item Kommandoer skal kunne eksekvere som baggrundsprocesser (ved brug af \&) såadan at mange programmer kan køres på samme tid.
\item Der skal være indbygget funktionalitet som gør de muligt at lave redirection af stdin og stdout til filer. F.eks skal kommandoen {\tt wc -l < /etc/passwd > antalkontoer} lave en fil ”antalkontoer“, der indeholder antallet af brugerkontoer.
\item Det skal være muligt at anvende pipes. F.eks. skal {\tt ls | wc -w} udskrive antallet af filer.
\item Funktionen {\tt exit} skal være indbygget til at afslutte shell’en.
\item Tryk på Ctrl-C skal afslutte det program, der kører i {\tt bosh} shell’en, men ikke shell’en selv.
\end{enumerate}

Følgende vil handle om vores implementation af disse features 


\chapter{Implementation og teori}
\section{Feature 1 og 2}
Første krav til vores shell er at vi ikke bruger andre shells til at få vores shell eller systemkald til at virke. Det skal altså være et selvstående program. En shell er en grafisk brugergrænseflade der tillader brugeren at inputte og køre programmer. Shellen er altså en process der kan starte andre programmer som processer. For at en bruger kan eksekvere programmer på maskinen så som {\tt ls}, {\tt cat} og {\tt wc} skal vi kigge i de forskelle {\tt bin} arkiver. Vi har skrevet vores shell til linux systemer, og vi leder derfor efter det inputtede program i mapperne {\tt ./}, {\tt /bin/} og {\tt /usr/bin/}. Hvis vi finder programmet som brugeren prøver at starte bruger vi vi det indbyggede program i linux {\tt execvp}. {\tt execvp} programmet tager en process og bytter det ud med en anden process. Det første vi gør er derfor at oprette en nye process med {\tt fork()}. Fork opretter en kopi af den eksisterende process. Den nye process kaldes for en \textit{child process} og den eksisternede process for en \textit{parrent process}. Dette gøres med følgende kode.

\begin{lstlisting}

... Parrent process code

pid_t pid = fork();
if(pid == 0){
    ... Child process code ...
}else{
    ... Parrent process code ...
}

... Parrent and child process code ...

\end{lstlisting}

Når vi har lavet et kopi af shell processen bytter vi ved brug af {\tt execvp} \textit{child processen} ud med det program som brugeren ønskede at starte. På den måde kan vi starte programmer som nye processer fra vores BOSC shell.

\section{Feature 3}

Hvis en kommando køres med symbolet {\tt \&} skal processen startes som en baggrundsprocess. Vi ønsker denne feature fordi at en bruger skal kunne køre flere programmer fra shell'en på samme tid. Når vi starter en process vil vi gerne vente på den terminiene inden vi igen tillader input fra brugeren. Dette gør vi med {\tt waitpid(process_id, status_location, options)}. Når vi starter en baggrundsproces vælger altså derfor blot ikke at vente på barne processen og lader derfor strakts brugeren indtaste nyt input. Som det kan ses i kode stykket nedenfor venter vi derfor kun på barne processen hvis {\tt background} er {\tt 0} ({\tt false}). {\tt shellcmd} er en struct vi bruger til at holde brugerens kommando. 
\begin{lstlisting}
int executeshellcmd(Shellcmd *shellcmd){
    

    ... code to check shellcmd

    pid_t pid = fork();
    if(pid == 0){
           ... Code executing the user input program ...
    }else{
        if(shellcmd -> background == 0){
            int wstatus = 0;    
            waitpid(pid,&wstatus,0);
        }
    }
    return 0;
}
\end{lstlisting}

\section{Feature 4}

Hvis symbolet {\tt >} optræder i kommandoen skal vi omdirigere output til filnavnet på venstre side. eg. {\tt cmd > file}. På samme måde skal vi hvis symbolet {\tt <} optræder i kommandoen omdirigere input til at være filen fra venstre side. eg {\tt cmd < file}. Dette har vi løst med følgende logik.

\begin{lstlisting}
if(in == NULL && out == NULL){
                status = executecmd(cmdlist);
            }else{
                if(in != NULL && out != NULL) status = redirInOut(in, out, cmdlist);
                if(in != NULL) status = redirIn(in, cmdlist);
                if(out != NULL) status = redirOut(out, cmdlist);
            }
\end{lstlisting}

som bruger følgende hjælpe metoder.

\begin{lstlisting}
// redirect in and out
int redirInOut(char *inFile, char *outFile, Cmd *cmdlist){
    
    int fidIn  = open(inFile, O_RDONLY);
    int fidOut = open(outFile, O_WRONLY | O_CREAT | O_APPEND);              
    close(0); close(1);
    dup(fidIn); dup(fidOut);
    int status = executecmd(cmdlist);
    close(fidIn); close(fidOut);
    if(status != 0) 
        printf("execvp returned: %i, errno returned: %i 'no such file or directory' \n", status, errno);

}

// redirect in
int redirIn(char *inFile, Cmd *cmdlist){
    int fid = open(inFile, O_RDONLY);  
    close(0); // close standard input
    dup(fid);   // 'duplicate fileid', opens another input (file)    
    int status = executecmd(cmdlist);
    close(fid);             
    if(status != 0) 
        printf("execvp returned: %i, errno returned: %i 'no such file or directory' \n", status, errno);


}

// redirect out
int redirOut(char *outFile, Cmd *cmdlist){
    int fid = open(outFile, O_WRONLY | O_CREAT | O_APPEND);         
    close(1); // close standard output
    dup(fid); // duplicate file-descriptor

    int status = executecmd(cmdlist);
    close(fid);             
    if(status != 0) 
        printf("execvp returned: %i, errno returned: %i 'no such file or directory' \n", status, errno);

}
\end{lstlisting}





\section{Feature 5}

En pipe (skrives med symbol {\tt |}) tager outputtet fra kommandoen på højre side og bruger det som input til kommandoen på venstre side. eg {\tt c1 | c2 | c3 } tager output fra c1 og giver til c2 som input osv. Vi har i vores shell implementeret dette med følgende logik. Denne metode kaldes af de metoder som var vist i feature 4.

\begin{lstlisting}
int executecmd(Cmd *cmdlist){
    int status;
    char **cmd = cmdlist -> cmd;
    Cmd *next = cmdlist -> next;
    if(next != NULL){

        int fd[2];
        pipe(fd);

        pid_t pid = fork();
        if(pid == 0){
            close(fd[0]);
            close(1);
            dup(fd[1]);
            close(fd[1]);
            status = executecmd(next);
        }else{
            close(fd[1]);
            close(0);
            dup(fd[0]);
            close(fd[0]);
            status = execvp(*cmd,cmd);
            
            int wstatus;
            waitpid(pid,&wstatus,0);
        }
    }else{
        status = execvp(*cmd,cmd);
    }
    return status;
}

\end{lstlisting}

\section{Feature 6}

%Denne funktion er allerede forklaret som en del af feature 6. 

I 'executeshellcmd' samler vi alle commands og sender dem til funktionen 'isValidCmd' for validering (unødvendigt, da execute funktionerne allerede returnerer -1 hvis en command ikke findes). Som sagt under Feature 2 returnerer denne funktion -1 Hvis 'exit' er en command. 'executeShellCmd' returnerer så umiddelbart 1 til 'main' metoden. Dermed terminerer while loopet i 'main' og vores shell slutter. 

I executeShellCmd() samler vi alle commands og sender dem til validering. Hvis status er -1 returnerer vi fra funktionen.

\begin{lstlisting}
while( cmdlist != NULL){
	char **cmd = cmdlist -> cmd;
	cmdlist = cmdlist -> next;
	status = isValidCmd(cmd);

	if(status == 0){ 
		printf("%s: command not found\n", *cmd );
		return 0;
	}
	if(status == -1) return 1;
}
\end{lstlisting}

I isValidCmd() returnerer vi -1 hvis 'exit' er en command.
\begin{lstlisting}
int isValidCmd(char **cmd){
	
	if(strncmp(*cmd,"exit",4) == 0) return -1;
\end{lstlisting}

I main(). Terminering af while loopet afslutter vores shell. 
\begin{lstlisting}
/* parse commands until 'exit' command, then exit */
while (!terminate) {
	terminate = executeshellcmd(&shellcmd);
\end{lstlisting}

\section{Feature 7}

Denne feature nåede ikke at blive implementeret i vores {\tt BOSH} shell.

\chapter{Konklusion}
\end{document}          
